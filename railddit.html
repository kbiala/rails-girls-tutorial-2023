<!DOCTYPE html>
<html lang="en">
<head>
  <title>Rails Girls Tutorial 2023</title>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap 5.3 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <header class="header text-white py-4">
    <nav class="navbar navbar-expand-xl" data-bs-theme="dark">
      <div class="container">
        <a class="navbar-brand" href="#">
          <h1 class="d-inline-block h5 mb-0">Rails Workshops Tutorial</h1>
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
            <li class="nav-item">
              <a class="nav-link" href="index.html#intro">Intro</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="index.html#internet">How Internet Works</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="index.html#html">Static HTML</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="index.html#dynamic-pages">Dynamic Pages</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="index.html#ruby">Ruby</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="index.html#rails">Rails</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="index.html#materials">Materials</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
  </header>


  <main class="bg-light text-dark py-5">
    <div class="container">
      <section>
        <h2 class="h3">"Railddit"</h2>
        <p>
          In this tutorial, we're going to create a&nbsp;simple social app, where users can post entries and score them.
          In the&nbsp;next steps, you can implement more features, like comments, user profiles with authorization,
          uploading images, etc.
        </p>
        <p>
          In this tuturial we're going to use Github Codespaces. If you're working on your local machine, you still can
          follow this tutorial, but you'll need to slightly change some of the&nbsp;commands.
        </p>
      </section>

      <hr class="my-5" />

      <section>
        <h3 class="h4">Creating a&nbsp;new app.</h3>
        <p>
          Go to the&nbsp;terminal in your Codespace and run the&nbsp;following command:
          <code class="fw-bold">bin/rails new&nbsp;.&nbsp;--css tailwind</code><br />
          <small>
            If you're working on your local machine, replace dot with your application name, eg.:
            <code>bin/rails new&nbsp;railddit&nbsp;--css tailwind</code>
          </small>
        </p>
        <p>
          This command will create a&nbsp;new Rails app with Tailwind CSS framework. You can also use Bootstrap or Bulma,
          or skip this flag completely and setup pure Rails application. See all available options by running:
          <code>bin/rails&nbsp;new&nbsp;--help</code>.
        </p>
        <p>
          You should now see a&nbsp;bunch of new files generated by this command. If everything went well, you should
          be able to run your app. To do that, type in the&nbsp;terminal: <code class="fw-bold">bin/rails&nbsp;server</code>.
          Click on the&nbsp;link that will appear in the&nbsp;terminal, that will open you app in a&nbsp;new browser tab.
        </p>

        <h3 class="h5">Configuring the app to work in Github Codespace.</h3>
        <p>Skip this step if you're working on your local machine.</p>
        <p>
          If you're using Codespaces, you need to do one more step. Copy the&nbsp;line that is displayed in the&nbsp;browser tab, and put it inside config/environments/development.rb
          file, inside <code>Rails.application.configure</code> block, so that it looks similar to the&nbsp;following:
        </p>
        <pre class="alert alert-danger">
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.
  ...
  <strong>config.hosts << "GENERATED_ADDRESS.preview.app.github.dev"</strong>
end
        </pre>
        <p>
          Now restart your Rails server by pressing Ctrl+C in the&nbsp;terminal, and running <code>bin/rails&nbsp;server</code> again.
        </p>

        <h4 class="h5">Congratulations! You've just created your first Rails application!</h4>
        <p>
          Before moving further, let's take a&nbsp;moment to look at the&nbsp;files that were generated by
          the <code>bin/rails&nbsp;new</code> command.
        </p>
        <p class="alert alert-dark" role="alert">
          <strong>Coach:</strong> Explain generated files structure. What is the&nbsp;purpose of main files? Introduce
          attendees to MVC pattern, and briefly explain main responsibilities of each part.
        </p>
        <p class="p-2 p-lg-4 bg-white rounded border">
          <img class="w-100" src="mvc.svg" />
        </p>
      </section>

      <hr class="my-5" />

      <section>
        <h3 class="h4">Generating entries.</h3>
        <p>
          One of the&nbsp;things that Rails provides out of the&nbsp;box is <strong>generators</strong>. It's a&nbsp;command
          for introducing a&nbsp;new resource into our application (eg. entries, users, posts, comments, products).
          It generates a&nbsp;bunch of files necessary for representing and interacting with this resource, so that we
          don't have to create everything manually.
        </p>
        <p>
          There are several types of generators. For a&nbsp;start, we're going to use <strong>scaffold generator</strong>,
          that will create the&nbsp;whole package for us: a&nbsp;model (with migration), views, routes and controller with basic
          actions (creating, reading, updating and destroying data, CRUD in short).
        </p>
        <p>
          Before moving further, open another terminal tab and type: <code>bin/rails&nbsp;tailwindcss:watch</code>.
          Thanks to that, Rails will generate views for us already with Tailwind CSS classes (you'll see it in action
          in a&nbsp;few minutes). Go back to the&nbsp;first tab and restart Rails server. Keep both terminal tabs open
          while developing your app.
        </p>
        <p>
          We can check rails scaffold generator syntax in <a href="https://guides.rubyonrails.org/generators.html" target="_blank">Rails documentation</a>.
          It looks as follows: <code>bin/rails&nbsp;generate&nbsp;scaffold&nbsp;ModelName&nbsp;field:type</code>.<br/>
          We'll call the&nbsp;main resource in the&nbsp;app <strong>entries</strong>. We want them to have a&nbsp;title, content
          and a&nbsp;tag. So the&nbsp;command in our case will look as follows:<br />
          <code class="fw-bold">bin/rails&nbsp;generate&nbsp;scaffold&nbsp;Entry title:string content:text tag:string</code>
        </p>
        <p>
          Can you recognise the files that were generated? Among them you should be able to see a&nbsp;new model (Entry.rb),
          controller (EntriesController.rb), and views (views/entries directory). Notice how naming conventions differ
          between models and controllers. Models are singular, controllers and views directory are plural. You'll follow
          the&nbsp;same convention when generating your own code.
        </p>
        <p>
          Let's check generated migration - you should be able to find it in db/migrate directory. If everything looks
          okay to you, run <code class="fw-bold">bin/rails&nbsp;db:migrate</code> in the&nbsp;terminal to apply this migration.
        </p>
        <p class="alert alert-dark" role="alert">
          <strong>Coach:</strong> Explain what migrations are and why we need them.
        </p>
        <p>
          Restart your server and check the&nbsp;results in the&nbsp;browser. Spend a&nbsp;few minutes on playing with generated
          views through the&nbsp;browser - create some entries, try to edit and delete them. Check how URLs look like. How is
          the&nbsp;URL looks like when you display single entry, and how it looks when you display the&nbsp;list of all entries?
        </p>

        <h3 class="h4">Updating root path.</h3>
        <p>
          We want to display entries on the main page of our app. To do that, we need to update the&nbsp;root path.
          go to config/routes.rb file and add the following line inside Rails.application.routes.draw block:
          <code>root "entries#index"</code>.
        </p>
        <p class="alert alert-dark" role="alert">
          <strong>Coach:</strong> Explain code parts: root, controller, action.
        </p>
      </section>

      <hr class="my-5" />

      <section>
        <h3 class="h4">Updating entry appearance.</h3>
        <p>
          We'll now tweak the&nbsp;appearance of our entries, so that they're displayed in cards, one under another.
          To achieve that, we'll need to update <strong>views</strong>. Go to app/views/entries/ and take a&nbsp;look at
          files in this directory. Notice that they have .html.erb extension. It means that they're HTML files (that we
          already know from previous lessons), but they also contain some Ruby code. Ruby variables are generated in
          controller and passed to the&nbsp;view.
        </p>
        <p>
          The action that displays the&nbsp;list of all entries is called <strong>index</strong>, and the&nbsp;corresponding view
          is entries/index.html.erb. But index file uses _entry.html.erb partial, that ensures that every entry is
          displayed in the&nbsp;same way. So we'll need to edit _entry.html.erb file. Open it in your code editor.
        </p>
        <p>
          Take a&nbsp;look at the code and compare it to what you can see in the&nbsp;browser. Can you find the&nbsp;part responsible
          for displaying entry title?
        </p>
        <p class="alert alert-dark" role="alert">
          <strong>Coach:</strong> Explain the&nbsp;role of &lt;%= %&gt; code.
        </p>
        <p>
          To edit a&nbsp;single entry, open <strong>views/entries/_entry.html.erb file</strong>. Use the&nbsp;knowledge
          gained during the&nbsp;workshops so far to:
        </p>
        <ul>
          <li>replace entry container <code>div</code> tag with <code>article</code> in _entry.html.erb</li>
          <li>
            add Tailwind classes to article tag that will display entry in a&nbsp;card
            (<a href="https://v1.tailwindcss.com/components/cards">see docs</a>)
          </li>
          <li>
            remove auto-generated labels that display attributes names (eg. <code>&lt;strong&gt;Title:&lt;/strong&gt;</code>)
          </li>
          <li>remove horizontal line (<code>&lt;hr/&gt;</code>)</li>
          <li>
            add creation date at the top of the&nbsp;card (the&nbsp;entry attribute that stores this information is
            called created_at)
          </li>
          <li>display entry title in <code>h2</code> tag, and make it bold</li>
          <li>
            shorten links names to "Show" and "Edit" (links in Ruby are generated by <code>&lt;%= link_to %&gt;</code> tags)
          </li>
          <li>
            remove classes from "Show" and "Edit" links, so that they're displayed as text, instead of buttons
          </li>
          <li>
            change colors of "Show" and "Edit" links to dark gray, and make them smaller (google Tailwind classes for
            font size and color); do the same for creation date
          <li>
            adjust margins to your liking (<code>mb-X</code> and <code>my-X</code> classes)
          </li>
        </ul>
        <p class="alert alert-dark" role="alert">
          <strong>Coach:</strong> Help with explaining, adding and editing Ruby tags.
        </p>
        <p>
          We can also style entry tag attribute as button, and move it next to the&nbsp;title. To do that, we'll use
          <code>&lt;button&gt;</code> tag with Tailwind classes:
        </p>
        <pre class="alert alert-danger">
&lt;div class="mb-2"&gt;
  &lt;h2 class="font-bold inline-block"&gt;&lt;%= entry.title %>&lt;/h2&gt;
  &lt;button class="bg-gray-400 hover:bg-gray-300 text-white py-1 px-2 rounded-full text-xs"&gt;
    &lt;%= entry.tag %&gt;
  &lt;/button&gt;
&lt;/div&gt;
        </pre>
        <p>
          Finally, we can add background colors, so that our cards stand out. To do that, we'll need to add
          <code>bg-white</code> class to <code>article</code> tag in _entry.html.erb and <code>bg-blue-50</code>
          to <code>body</code> tag in views/layouts/application.html.erb file.
        </p>
        <p>
          After these changes, the homepage should now resemble social app with entries displayed in cards, one
          under another. My _entry.html.erb file looks like follows:
        </p>
        <pre class="alert alert-danger">
&lt;article id="&lt;%= dom_id entry %&gt;" class="border border-gray-300 bg-white rounded-md shadow p-4 mb-3"&gt;
  &lt;div class="text-xs text-gray-500 mb-3"&gt;
    Posted on &lt;%= entry.created_at %&gt;
  &lt;/div&gt;

  &lt;div class="mb-2"&gt;
    &lt;h2 class="font-bold inline-block"&gt;&lt;%= entry.title %>&lt;/h2&gt;
    &lt;button class="bg-gray-400 hover:bg-gray-300 text-white py-1 px-2 rounded-full text-xs"&gt;
      &lt;%= entry.tag %&gt;
    &lt;/button&gt;
  &lt;/div&gt;

  &lt;div class="mb-3"&gt;
    &lt;%= entry.content %&gt;
  &lt;/div&gt;

  &lt;% if action_name != "show" %&gt;
    &lt;%= link_to "Show", entry, class: "inline-block font-bold text-xs text-gray-500 mr-3" %&gt;
    &lt;%= link_to 'Edit', edit_entry_path(entry), class: "inline-block font-bold text-xs text-gray-500" %&gt;
  &lt;% end %&gt;
&lt;/article&gt;
        </pre>
      </section>

      <hr class="my-5" />

      <section>
        <h3 class="h4">Let's add scoring feature.</h3>
        <p>
          One of the&nbsp;main features we want in our app is scoring. We want users to be able to score entries by clicking
          on icons, up or down. We'll start with adding score attribute, that will store current score of each entry.
        </p>
        <h4 class="h5">First: migration.</h4>
        <p>
          Because we already have entries resource with model, views and controller, this time we'll use a&nbsp;different
          generator - migration generator, that will add a&nbsp;new attribute to our entries table in database. The syntax of
          this generator looks like this: <code>bin/rails generate migration AddAttributeNameToTableName attribute_name:attribute_type</code>.
          So in our case we'll run: <code class="fw-bold">bin/rails generate migration AddScoreToEntries score:integer</code>.
          Let's open generated file in db/migrate folder. If we made some mistake, we can fix it now manually. If everything
          looks okay, we can apply the migration with <code class="fw-bold">bin/rails db:migrate</code> command.
        </p>
        <h4 class="h5">Add score and arrows to entry view.</h4>
        <p>
          Now, let's display the score in our entries, and let's add the&nbsp;arrows that we'll later use for increasing and
          descresing score. I added a&nbsp;separate column to my _entry view and added classes to display score+arrows on the&nbsp;left,
          and the&nbsp;rest of the&nbsp;entry on the&nbsp;right. I also used svg images to display arrows, but you can use
          simple icons if you prefer. My _entry.html.erb file now looks like this:
        </p>
        <pre class="alert alert-danger">
&lt;article id="<%= dom_id entry %>" class="flex overflow-hidden border border-gray-300 bg-white rounded-md shadow mb-3"&gt;
  &lt;div class="flex-none text-center bg-gray-50 font-bold w-10 pt-3"&gt;
    &lt;div&gt;
      &lt;%= image_tag("arrow-up.svg", width: "16", class: "mx-auto") %&gt;
    &lt;/div&gt;
    &lt;div class="my-2 text-xs"&gt;
      &lt;%= entry.score %&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;%= image_tag("arrow-down.svg", width: "16", class: "mx-auto") %&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div class="flex-auto p-4"&gt;
    &lt;p class="text-xs text-gray-500 mb-3"&gt;
      Posted on &lt;%= entry.created_at %&gt;
    &lt;/p&gt;

    &lt;div class="mb-2"&gt;
      &lt;h2 class="font-bold inline-block"><%= entry.title %&gt;&lt;/h2&gt;
      &lt;button class="bg-gray-400 hover:bg-gray-300 text-white py-1 px-2 rounded-full text-xs"&gt;
        &lt;%= entry.tag %&gt;
      &lt;/button&gt;
    &lt;/div&gt;

    &lt;div class="mb-3"&gt;
      &lt;%= entry.content %&gt;
    &lt;/div&gt;

    &lt;% if action_name != "show" %&gt;
      &lt;%= link_to "Show", entry, class: "inline-block font-bold text-xs text-gray-500 mr-3" %&gt;
      &lt;%= link_to 'Edit', edit_entry_path(entry), class: "inline-block font-bold text-xs text-gray-500" %&gt;
    &lt;% end %&gt;
  &lt;/div&gt;
&lt;/article&gt;
        </pre>

        <h4 class="h5">Define increase and descrease score methods.</h4>
        <p>Open entries_controller and add: </p>
        <pre class="alert alert-danger">
class EntriesController < ApplicationController
  before_action :set_entry, only: %i[ show edit update destroy <span class="fw-bold">increase_score decrease_score</span> ]
  ...

  <span class="fw-bold">def increase_score</span>
  <span class="fw-bold">end</span>

  <span class="fw-bold">def decrease_score</span>
  <span class="fw-bold">end</span>

  private
  ..
end
        </pre>
        <p>
          The first one, increase_score, should increase entry's score by 1, and decrease_score should decrease entry's
          score by 1. Now let's add content of our actions. So first, we need to recalculate entry's score, then we need to
          save a&nbsp;new score in db (to make it permanent), and finally we'll return a&nbsp;new score - we'll need this value later.
          Our code should now look like this:
        </p>
        <pre class="alert alert-danger">
  def increase_score
    @entry.score += 1
    @entry.save
    render plain: @entry.score
  end
        </pre>
        <p>
          The last line returns the&nbsp;new score as plain text. Every Rails controller must either redirect to other controller
          method, or return something: html (view), json (data), or plain text (string). We chose the last option, because
          we'll use this score string in our JS controller in a&nbsp;moment.
        </p>
        <p>
          Do the same for the second method.
        </p>

        <h4 class="h5">Routes for score methods.</h4>
        <p>
          Every controller action needs to have a&nbsp;route that connects URL with the&nbsp;controller&nbsp;&&nbsp;action that processes
          the&nbsp;request. When we used scaffold for entries at the&nbsp;beginning of this tutorial, routes were generated automatically
          for us. Now we need to add them manually. So let's open the contig/routes.rb file and add update as follows:
        </p>
        <pre class="alert alert-danger">
Rails.application.routes.draw do
  resources :entries do
    <span class="fw-bold">get 'increase_score', on: :member</span>
    <span class="fw-bold">get 'decrease_score', on: :member</span>
  end
  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html

  # Defines the root path route ("/")
  root "entries#index"
end
        </pre>
        <p>
          We've put the&nbsp;new lines inside <code>:entries</code> block, so the&nbsp;new routes will be captured by entries controller.
          The&nbsp;first word in the&nbsp;line is the <a href="https://www.w3schools.com/tags/ref_httpmethods.asp" target="_blank">HTTP method</a>,
          and the&nbsp;second one is the&nbsp;name of the action in entries controller. The <code>on:&nbsp;:member</code> part means that
          the&nbsp;route will be generated for every single entry, not for the&nbsp;whole collection (group of entries), like eg. index action.
          We can check our routes by running <code>rails routes</code> command in the&nbsp;terminal. Check various ways of defining routes
          in <a href="https://guides.rubyonrails.org/routing.html" target="_blank">Rails routing guide</a>.
        </p>

        <h4 class="h5">Add JS controller.</h4>
        <p>
          Now, we want to call our Rails methods dynamically, without reloading the&nbsp;page. There's a&nbsp;couple of ways to
          achieve this result. In this tutorial we'll use StimulusJS. It's a&nbsp;small JavaScript (JS) framework that allows
          us to add interactivity to our Rails views. It's easy to use, and already installed in your Rails app, configured,
          and ready to use. First, we need to create a&nbsp;Stimulus (JS) controller. Create a&nbsp;new file in app/javascript/controllers
          called scores_controller.js and add basic default structure inside:
        </p>
        <pre class="alert alert-danger">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  // our code will go here
}
        </pre>
        <p>
          We'll also need two methods that will be called when user clicks on the&nbsp;up or down arrow. Let's add them, and
          let's put <code>console.log()</code> lines inside that will print out something in the&nbsp;browser console. This way
          we'll see if the methods are called correctly. Our JS controller should now look like this:
        </p>
        <pre class="alert alert-danger">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  up(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    console.log("Arrow up clicked")
  }

  down(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    console.log("Arrow down clicked")
  }
}
        </pre>

        <h4 class="h5">Connect JS controller with view.</h4>
        <p>
          We now need to connect arrows in views with up() and down() functions in JS controller. To achieve this, we need
          add code in our entry view. Let's open _entry.html.erb file, and add <code>data-controller=''</code> property to div
          that contains arrows like this:
          <code>&lt;div class="flex-none text-center bg-gray-50 font-bold w-10 pt-3" <span class="fw-bold">data-controller='scores'</span>&gt;</code>.
          Value of this property will be the same as the&nbsp;name of our JS controller (scores in our case).
        </p>
        <p>
          Secondly, we need to add a&nbsp;link tag around every arrow, with <code>data-action</code> property. This property will be called after
          JS controller, function inside it (in our case, it's <em>up</em> or <em>down</em>), and will also say in which situation
          it should be triggered (in our case, after click). So the code will look like this:
        </p>
        <pre class="alert alert-danger">
&lt;%= link_to '/', class: 'block', remote: true, 'data-action': 'click->scores#up' do %&gt;
  &lt;%= image_tag("arrow-up.svg", width: "16", class: "mx-auto") %&gt;
&lt;% end %&gt;
        </pre>
        <p>
          Do the&nbsp;same for the&nbsp;second arrow.
        </p>
        <p>
          We can now test our code. Run Rails server, open browser console, and click on the&nbsp;arrows. You should see
          the&nbsp;text generated by console.log method.
        </p>

        <h4 class="h5">Connect JS controller with Rails controller.</h4>
        <p>
          We have JS controller and views correctly connected to it, so now we need to connect JS with increase_ and
          decrease_score methods. First we'll add <code>data-scores-id-value=""</code> and <code>data-scores-target=""</code>
          to _entry.html.erb. The&nbsp;first one will tell JS which entry we're working on, so we need to include entry id as
          its value like this:
        </p>
        <pre class="alert alert-danger">
&lt;div class="flex-none text-center bg-gray-50 font-bold w-10 pt-3" data-controller='scores' <span class="fw-bold">data-scores-id-value="&lt;%=entry.id%&gt;</span>"&gt;
        </pre>
        <p>
          The&nbsp;second one will tell JS method where to put the&nbsp;new score value after we update it. We need to call this place
          somehow (I used <em>sum</em> name, but feel free to use a&nbsp;better name). So the&nbsp;code will look like this:
        </p>
        <pre class="alert alert-danger">
&lt;div class="my-2 text-xs" <span class="fw-bold">data-scores-target="sum"</span>&gt;
  &lt;%= entry.score %&gt;
&lt;/div&gt;
        </pre>
        <p>
          We also need to add a&nbsp;related code inside JS scores controller:
        </p>
        <pre class="alert alert-danger">
export default class extends Controller {
  <span class="fw-bold">static targets = [ "sum" ]</span>
  <span class="fw-bold">static values = { id: Number }</span>
  ...
}
        </pre>

        <p>
          The&nbsp;last step. We need to update JS controller. Let's start with up() function. Start below console.log line.
          Add auxiliary variables - first one will store entry id, second one will store url of increase_score method, and
          the&nbsp;last one will point to the&nbsp;place in html where we display the&nbsp;score. We'll use them later.
        </p>
        <pre class="alert alert-danger">
let id = this.idValue
let url = `/entries/${id}/increase_score`
let scoreSum = this.sumTarget
        </pre>

        <p>
          Now we'll add a&nbsp;JS <code>fetch</code> method that connects to Rails method and receives and processes the&nbsp;result.
          Here's the&nbsp;general syntax of the&nbsp;fetch method:
        </p>
        <pre class="alert alert-danger">
fetch(url).then((response) => response.text()).then(response => {
  // handle the&nbsp;response
})
        </pre>
        <p>
          We can add <code>console.log</code> inside, to see the&nbsp;response from Rails controller:
        </p>
        <pre class="alert alert-danger">
fetch(url).then((response) => response.text()).then(response => {
  console.log(response)
})
        </pre>
        <p>
          It should show the&nbsp;updated score. Now we just need to put it back in _entry.html.erb view. We'll use
          scoreSum variable that we created before like this:
        </p>
        <pre class="alert alert-danger">
fetch(url).then((response) => response.text()).then(response => {
  scoreSum.textContent = response
})
        </pre>
        <p>
          It replaces currently displayed (old) score, with the&nbsp;new one.
        </p>
        <p>
          Time to test the&nbsp;code in the&nbsp;browser! If everything works as expected, you can remove <code>console.log</code>
          lines - we no longer need them. And the&nbsp;score feature is ready.
        </p>
      </section>

      <hr class="my-5" />

      <section>
        <h3 class="h4">Let's talk about validating user data.</h3>
        <p>
          We played with views, we played with controllers, now it's time to play with models.
        </p>
        <p>
          Perhaps you already noticed, that users can type whatever they want in entry fields, or even leave them empty.
          We don't want that. We want to make sure that entries have all the&nbsp;required information, and that it's valid.
          To make it happen, we need to add <strong>validations</strong> to our entry model.
        </p>
        <p>
          Let's open models/entry.rb file. We'll follow the syntax presented in
          <a href="https://guides.rubyonrails.org/active_record_validations.html" target="_blank">Rails Docs</a>, that
          starts with keyword <code>validates</code>, then we've got the name of attribute that we want to validate,
          and finally validation rules. For a&nbsp;start, let's make entry title required. We'll do that by adding
          <code>validates :title, presence: true</code> inside Entry class like this:
        </p>
        <pre class="alert alert-danger">
class Entry < ApplicationRecord
  validates :title, presence: true
end
        </pre>
        <p>
          Run Rails server and confirm it's working as expected. What happens when you try to create entry without title?
        </p>
        <p>
          Now, try to add validations for other attributes, eg. length validations. You'll find examples in Rails Docs.
          Leave one of the attributes optional, eg. entry <em>tag</em>. What happens if we try to add maximum length for
          tag? How can we allow tags between 2 and 20 characters, but at the same time optional? Try to find this
          information in Rails Docs.
        </p>
        <p>
          Let's see what happens now when we add an&nbsp;entry without a&nbsp;tag. In previous step we displayed entry
          tags as buttons, so now if the button content is empty, it doesn't look very good. Let's tweak that. What we
          want to do now is to display tag only if it's present. We can do that with <code>if</code> statement. Let's
          open _entry.html.erb file, and add if statement around the <code>button</code> with entry.tag. The method that
          checks if attribute is present is called <code>present?</code>, so our if statement will look like this:
        </p>
        <pre class="alert alert-danger">
&lt;% if entry.tag.present? %&gt;
  ...
&lt;% end %&gt;
        </pre>
        <p>
          Replace elipsis with the code that displays the button. Check the results in browser.
        </p>
      </section>

      <hr class="my-5" />

      <section>
        <h3 class="h4">Let users add images to their entries.</h3>
        <p>
          We'll let users to add images to their entries. For a start, we'll choose a simpler approach. So in our system we'll only
          store URLs to images that have already been uploaded to the Internet somewhere. I suggest to add full upload feature
          as an&nbsp;extra task after you get familiar with Rails.
        </p>
        <p>
          The beginning is similar to what we did in scores feature - we need to generate a&nbsp;migration. Take a&nbsp;look
          at the syntax above, and try to generate a&nbsp;command yourself.
        </p>
        <p>
          Once you generate the&nbsp;migration, it's good practice to check it's content in db/migrate folder before applying it.
          You should see something similar to the&nbsp;following lines:
        </p>
        <pre class="alert alert-danger">
class AddImageUrlToEntries < ActiveRecord::Migration[7.0]
  def change
    add_column :entries, :image_url, :string
  end
end
        </pre>
        <p>If everything looks correct, you can apply migration by running <code>bin/rails db:migrate</code>.</p>

        <h4 class="h5">Add image_url field to entry form.</h4>
        <p>Open app/views/entries/_form.html.erb and add:</p>
        <pre class="alert alert-danger">
&lt;div class="my-5"&gt;
  &lt;%= form.label :image_url %&gt;
  &lt;%= form.text_field :image_url, class: "block shadow rounded-md border border-gray-200 outline-none px-3 py-2 mt-2 w-full" %&gt;
&lt;/div&gt;
        </pre>

        <h4 class="h5">Allow users to edit image_url field.</h4>
        <p>
          Add image_url to entry_params in entries_controller:
          <code>params.require(:entry).permit(:title, :content, :tag, <span class="fw-bold">:image_url</span>)</code>
          This will allow users to save image_url to database. We always need to specify which attributes are allowed
          to be edited by users. Read more about strong parameters
          <a href="https://edgeguides.rubyonrails.org/action_controller_overview.html#strong-parameters">here</a>.
        </p>

        <h4 class="h5">Display image in entry view.</h4>
        <p>
          Let's open _entry.html.erb view and add an image with image_tag tag:
          <code>&lt;%= image_tag entry.image_url %&gt;</code>
        </p>
        <p>
          Notice that the image is not correctly displayed if the image is not present. We can fix that by adding
          <code>if</code> statement. We'll use <code>present?</code> method again, so the code will look like this:
        </p>
        <pre class="alert alert-danger">
&lt;div class="mb-3"&gt;
  &lt;% if entry.image_url %&gt;
    &lt;%= image_tag entry.image_url %&gt;
  &lt;% end %&gt;
&lt;/div&gt;
        </pre>
      </section>

      <hr class="my-5" />

      <section>
        <h3 class="h4">Suggested next steps for your app.</h3>
        <p>
          If you're done with all the&nbsp;tasks, you can try to add some more features to your app. Here are some
          suggestions:
        </p>
        <ul>
          <li>
            Let users upload files from their computers. Check out
            <a href="https://guides.rubyonrails.org/active_storage_overview.html" target="_blank">Rails Docs</a>
            to learn more about uploading and setting up storage for images.
          </li>
          <li>
            Add authentication, so that users can log in and out. Check out <a href="https://github.com/heartcombo/devise" target="_blank">Devise</a>
            gem. You'll find a lot of useful tutorials online how to set up and use Devise gem. Just remember that you
            follow instructions for Rails v7.
          </li>
          <li>
            Once you have user accounts, try to connect them to entries. So that each entry is assigned (belongs) to a&nbsp;user.
            Read about <a href="https://guides.rubyonrails.org/association_basics.html" target="_blank">Active Record Associations</a>.
            After that you can display user who is an author of the&nbsp;entry in the&nbsp;entry view.
          </li>
          <li>
            Add comments to entries. Check out <a href="https://guides.rubyonrails.org/getting_started.html#adding-a-second-model" target="_blank">Rails Docs</a>
            to learn how to add a&nbsp;second resource associated with already existing one (in our case, comments
            assigned to entries).
          </li>
          <li>
            Once you have user accounts in your app, you can add authorization levels. For example, you can allow only
            registered and logged in users to add entries, and only entry author to edit or delete&nbsp;it. There's a&nbsp;couple
            of gems out there that will help you manage authorization. I suggest you check out
            <a href="https://www.rubydoc.info/gems/pundit" target="_blank">Pundit</a> or
            <a href="https://github.com/CanCanCommunity/cancancan/blob/develop/docs/README.md" target="_blank">CanCanCan</a>.
          </li>
        </ul>
      </section>

      <hr class="my-5" />

      <p class="lead fw-bold">Want to keep learning? Check out <a href="index.html#materials">these links</a>.</p>
    </div>
  </main>

  <footer class="footer text-dark py-5">
    <div class="container">
      2023 Klaudia Bia≈Ça
      <a href="https://github.com/kbiala" target="_blank">
        <img alt="GH logo"
             height="17"
             class="d-inline-block align-text-top ms-1"
             src="https://upload.wikimedia.org/wikipedia/commons/c/c2/GitHub_Invertocat_Logo.svg" />
      </a>
    </div>
  </footer>

  <!-- Bootstrap 5.3 JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
</body>
</html>
